<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Julen Gamboa">
<meta name="dcterms.date" content="2023-08-21">

<title>Credit Risk Analysis - ML models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="credit_risk_analysis_ml_models_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="credit_risk_analysis_ml_models_report_files/libs/quarto-html/quarto.js"></script>
<script src="credit_risk_analysis_ml_models_report_files/libs/quarto-html/popper.min.js"></script>
<script src="credit_risk_analysis_ml_models_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="credit_risk_analysis_ml_models_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="credit_risk_analysis_ml_models_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="credit_risk_analysis_ml_models_report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="credit_risk_analysis_ml_models_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="credit_risk_analysis_ml_models_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="credit_risk_analysis_ml_models_report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="credit_risk_analysis_ml_models_report_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="credit_risk_analysis_ml_models_report_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="credit_risk_analysis_ml_models_report_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Credit Risk Analysis - ML models</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Julen Gamboa </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 21, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="aim" class="level1">
<h1>Aim</h1>
<p>The aim of this analysis is to determine credit risk based on customer behaviour regarding engagement with financial products as well as a variety of demographic attributes that may be informative.</p>
<p>It’s worth noting that the dataset already contains information about credit risk</p>
<section id="data-source" class="level2">
<h2 class="anchored" data-anchor-id="data-source">Data source</h2>
<p>In this analysis I’m using a <strong>Kaggle credit risk dataset</strong> described <a href="https://www.kaggle.com/datasets/praveengovi/credit-risk-classification-dataset">here</a></p>
<p>The data is structured in two csv files:</p>
<div>
<ol type="1">
<li>File 1 - <strong>Payment data</strong> contains customer’s credit card payment history and has the following fields:</li>
</ol>
<ul>
<li>id: customer id</li>
<li>OVD_t1: number of times overdue type 1</li>
<li>OVD_t2: number of times overdue type 2</li>
<li>OVD_t3: number of times overdue type 3</li>
<li>OVD_sum: total overdue days</li>
<li>pay_normal: number of times normal payment</li>
<li>prod_code: credit product code</li>
<li>prod_limit: credit limit of product</li>
<li>update_date: account update date</li>
<li>new_balance: current balance of product</li>
<li>highest_balance: highest balance in history</li>
<li>report_date: date of recent payment</li>
</ul>
</div>
<div>
<ol start="2" type="1">
<li>File 2 - <strong>Customer data</strong> which contains demographic data and category attributes that have been anonymised as follows:</li>
</ol>
<ul>
<li>id</li>
<li>label: if it equals 1 it indicates the customer is high risk, if it equals 0 the customer is low risk</li>
<li>fea_1</li>
<li>fea_2</li>
<li>fea_3</li>
<li>fea_4</li>
<li>fea_5</li>
<li>fea_6</li>
<li>fea_7</li>
<li>fea_8</li>
<li>fea_9</li>
<li>fea_10</li>
<li>fea_11</li>
</ul>
</div>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<p>I have decided to make a second report where I concentrate on ML models because neural networks offered no significant improvement in accuracy of prediction for far more computational cost.</p>
<p>Below is the amended flowchart</p>
<div class="cell">
<div class="cell-output-display">
<div>
<div>
<pre class="mermaid mermaid-js">flowchart TD
  A[Input data] --&gt; B(EDA)
  B --&gt; C{Analysis}
  C --&gt; D{Logistic Regression}
  C --&gt; E{Naive Bayes}
  C --&gt; F{Decision Tree Classifier}
  C --&gt; G{XGBoost}
  D --&gt; H{Accuracy assessment}
  E --&gt; H{Accuracy assessment}
  F --&gt; H{Accuracy assessment}
  G --&gt; H{Accuracy assessment}
  H --&gt; I{Reporting}
  I --&gt; J{Select best two methods}
  J --&gt; K{Compare common and unique predictions}
</pre>
</div>
</div>
</div>
</div>
<section id="input-data-pre-processing" class="level3">
<h3 class="anchored" data-anchor-id="input-data-pre-processing">Input data pre-processing</h3>
</section>
<section id="note" class="level3">
<h3 class="anchored" data-anchor-id="note">Note:</h3>
<p>After some standard pre-processing (renaming columns, concatenating data frames, and checking for missing data) I decided that data imputation was not appropriate while low credit risk customers might pay their full balance or higher amounts consistently on the same date, high risk customers would exhibit far more variance on both the date of balance closing and last payments made. I personally feel the variable ‘pay_normal’ (i.e.&nbsp;the number of times a customer does not default on payments) captures this information in a discretised manner that does not rely on following a Poisson distribution of events.</p>
<p>In short, I have decided that dropping update_date, and report_date variables was justified. I did however use KNN imputation to fill missing values for feature_2, prod_limit (the credit limit), and highest_balance features, the data for feature 2 appears to be normally distributed, while the prod_limit appears to be close to normally distributed but has a small number of outliers. The highest_balance variable exhibits most values centered close to zero but extremely long tail all the way out to 150,000,000.</p>
<section id="no-missing-values-present-after-pre-processing" class="level5">
<h5 class="anchored" data-anchor-id="no-missing-values-present-after-pre-processing">No missing values present after pre-processing</h5>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>merged_df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 8250 entries, 0 to 8249
Data columns (total 21 columns):
 #   Column           Non-Null Count  Dtype  
---  ------           --------------  -----  
 0   id               8250 non-null   int64  
 1   feature_1        8250 non-null   int64  
 2   feature_2        8250 non-null   float64
 3   feature_3        8250 non-null   int64  
 4   feature_4        8250 non-null   float64
 5   feature_5        8250 non-null   int64  
 6   feature_6        8250 non-null   int64  
 7   feature_7        8250 non-null   int64  
 8   feature_8        8250 non-null   int64  
 9   feature_9        8250 non-null   int64  
 10  feature_10       8250 non-null   int64  
 11  feature_11       8250 non-null   float64
 12  OVD_t1           8250 non-null   int64  
 13  OVD_t2           8250 non-null   int64  
 14  OVD_t3           8250 non-null   int64  
 15  OVD_sum          8250 non-null   int64  
 16  pay_normal       8250 non-null   int64  
 17  prod_code        8250 non-null   int64  
 18  prod_limit       8250 non-null   float64
 19  new_balance      8250 non-null   float64
 20  highest_balance  8250 non-null   float64
dtypes: float64(6), int64(15)
memory usage: 1.4 MB</code></pre>
</div>
</div>
<p>It would be good to visualise how the different variables correlate with one another.</p>
<p><em>Technical note: The plot was generated with plotnine following Tidyverse principles which I find to be superior to Python libraries</em></p>
<div class="cell" data-execution_count="3">
<div class="cell-output cell-output-stderr">
<pre><code>/home/jgamboa/anaconda3/lib/python3.10/site-packages/plydata/cat_tools.py:443: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.
/home/jgamboa/anaconda3/lib/python3.10/site-packages/plotnine/scales/scale.py:143: PlotnineWarning: scale_fill_cmap could not recognise parameter `cmap`</code></pre>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="credit_risk_analysis_ml_models_report_files/figure-html/cell-4-output-2.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Correlation between different variables in the credit risk customer dataset</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>&lt;Figure Size: (800 x 600)&gt;</code></pre>
</div>
</div>
</section>
</section>
</section>
<section id="analyses" class="level2">
<h2 class="anchored" data-anchor-id="analyses">Analyses</h2>
<p>First thing here is to store the label used to classify a customer as high or low credit risk and store it as the response variable for all our models while keeping everything else as our predictor variables</p>
<section id="ml-models" class="level3">
<h3 class="anchored" data-anchor-id="ml-models">ML models</h3>
<p>Four methods will be used, Logistic Regression (LR), Naive Bayes (NB), a Decision Tree Classifier (DT), and XGBoost (XGB). The dataset is split into training and test sets, <strong>70%</strong> is kept for the training set and <strong>30%</strong> will be used as a test set.</p>
<p>Hyperparameter tuning was performed for both the DT and XGB models</p>
<p>The code is not shown but the prediction accuracy is reported below</p>
<div class="cell" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>Best random state after hyperparameter tuning for the Decision Tree Classifier
136
Best random state after hyperparameter tuning for XGBoost
0</code></pre>
</div>
</div>
<section id="reporting-the-results-of-our-models" class="level4">
<h4 class="anchored" data-anchor-id="reporting-the-results-of-our-models">Reporting the results of our models</h4>
<div class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<p><img src="credit_risk_analysis_ml_models_report_files/figure-html/cell-6-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code></code></pre>
</div>
</div>
</section>
<section id="selecting-the-best-methods-based-on-the-accuracy-scores" class="level4">
<h4 class="anchored" data-anchor-id="selecting-the-best-methods-based-on-the-accuracy-scores">Selecting the best methods based on the accuracy scores</h4>
<p>The reason why one would want to consider selecting the results of more than one method are many. For one, the way a given classifier method might choose a given outcome may be affected by specific statistical quirks of each method, for closely scoring methods one may want to see what predicted IDs are common to both methods and which ones aren’t in order to better understand what parameters might be more relevant to each model.</p>
</section>
<section id="visualising-differences-between-the-predicted-customers-common-to-both-models-and-those-that-are-unique-to-either-model" class="level4">
<h4 class="anchored" data-anchor-id="visualising-differences-between-the-predicted-customers-common-to-both-models-and-those-that-are-unique-to-either-model">Visualising differences between the predicted customers common to both models and those that are unique to either model</h4>
<section id="plot-all-high-risk-cases-predicted-by-both-xgboost-and-dt-models" class="level5">
<h5 class="anchored" data-anchor-id="plot-all-high-risk-cases-predicted-by-both-xgboost-and-dt-models">Plot all high risk cases predicted by both XGBoost and DT models</h5>
<div class="cell" data-execution_count="7">
<div class="cell-output cell-output-stderr">
<pre><code>/home/jgamboa/anaconda3/lib/python3.10/site-packages/plydata/cat_tools.py:443: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.
/home/jgamboa/anaconda3/lib/python3.10/site-packages/plotnine/scales/scale.py:143: PlotnineWarning: scale_fill_cmap could not recognise parameter `cmap`</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="credit_risk_analysis_ml_models_report_files/figure-html/cell-8-output-2.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>&lt;Figure Size: (800 x 600)&gt;</code></pre>
</div>
</div>
</section>
<section id="and-those-predicted-by-xgboost-but-not-the-decision-tree-classifier-model" class="level5">
<h5 class="anchored" data-anchor-id="and-those-predicted-by-xgboost-but-not-the-decision-tree-classifier-model">And those predicted by XGBoost but not the Decision Tree Classifier model</h5>
<div class="cell" data-execution_count="8">
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_61775/2740749301.py:4: FutureWarning: The default value of numeric_only in DataFrame.corr is deprecated. In a future version, it will default to False. Select only valid columns or specify the value of numeric_only to silence this warning.
/home/jgamboa/anaconda3/lib/python3.10/site-packages/plydata/cat_tools.py:443: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.
/home/jgamboa/anaconda3/lib/python3.10/site-packages/plotnine/scales/scale.py:143: PlotnineWarning: scale_fill_cmap could not recognise parameter `cmap`</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="credit_risk_analysis_ml_models_report_files/figure-html/cell-9-output-2.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>&lt;Figure Size: (800 x 600)&gt;</code></pre>
</div>
</div>
</section>
<section id="finally-those-predictions-made-by-the-decision-tree-classifier-model-but-not-xgboost" class="level5">
<h5 class="anchored" data-anchor-id="finally-those-predictions-made-by-the-decision-tree-classifier-model-but-not-xgboost">Finally those predictions made by the Decision Tree Classifier model but not XGBoost</h5>
<div class="cell" data-execution_count="9">
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_61775/2692289710.py:3: FutureWarning: The default value of numeric_only in DataFrame.corr is deprecated. In a future version, it will default to False. Select only valid columns or specify the value of numeric_only to silence this warning.
/home/jgamboa/anaconda3/lib/python3.10/site-packages/plydata/cat_tools.py:443: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.
/home/jgamboa/anaconda3/lib/python3.10/site-packages/plotnine/scales/scale.py:143: PlotnineWarning: scale_fill_cmap could not recognise parameter `cmap`</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="credit_risk_analysis_ml_models_report_files/figure-html/cell-10-output-2.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>&lt;Figure Size: (800 x 600)&gt;</code></pre>
</div>
</div>
<p>We can see that the features that matter to predict high risk are the same for both XGBoost and DT models. However, there are some differences in the correlation values possibly arising from differences in sensitivity between ensemble models (XGBoost) and other classifier models such as decision tree classifiers. Whether the sensitivity threshold in making these predictions should be tweaked or not would depend on how much risk can be tolerated but both models perform well, although XGBoost shows marginally better performance.</p>
</section>
</section>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>